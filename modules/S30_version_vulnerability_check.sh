#!/bin/bash

# emba - EMBEDDED LINUX ANALYZER
#
# Copyright 2020 Siemens AG
#
# emba comes with ABSOLUTELY NO WARRANTY. This is free software, and you are
# welcome to redistribute it under the terms of the GNU General Public License.
# See LICENSE file for usage of this software.
#
# emba is licensed under GPLv3
#
# Author(s): Michael Messner, Pascal Eckmann, Stefan HabÃ¶ck

# Description:  Iterate trough all binaries and check if these occurs in the CVE database
#               Access:
#                 firmware root path via $FIRMWARE_PATH
#                 binary array via ${BINARIES[@]}


S30_version_vulnerability_check() {
  module_log_init "s30_version_vulnerability_check"
  module_title "Version Vulnerability Check"
  CONTENT_AVAILABLE=0

  if [[ "$(wc -l "$CONFIG_DIR""/version_strings.cfg" | cut -d\  -f1 2>/dev/null)" -gt 0 ]]; then
    if [[ $V_FEED -eq 1 ]]; then
      CONTENT_AVAILABLE=1
      print_output "[*] Vulnerability database found!"
      echo
      for LINE in "${BINARIES[@]}"; do
        if (file "$LINE" | grep -q "ELF"); then
          local V_OUTPUT_G
          V_OUTPUT_G="$(config_grep "$CONFIG_DIR""/version_strings.cfg" "$LINE")"

          #filtering with manual blacklist ...
          readarray -t V_OUTPUT < <(echo "${V_OUTPUT_G[@]}" | grep -v '127.0.0.1' | grep -v '1.1.1.1' \
          | grep -v '0.0.0.' | grep -v '8.8.8.8' | grep -v '192.168.0' | grep -v '192.168.1' | grep -v '224.0.0.252' \
          | grep -v '255.255.255.' | sort -u )

          local VULNS
          readarray -t VULNS < <(grep -i "\\s""$(basename "$LINE")""\\s" "$VUL_FEED_DB" | sed "s/\"\"//g" | cut -d\| -f1 | cut -d, -f1,3- | sed "s/,/   /" | cut -d\" -f1,2 | sed "s/\"//" 2>/dev/null)

          # if we found less than 10 vulnerabilities, we print it here:
          if [[ ${#VULNS[@]} -gt 0 ]] && [[ ${#VULNS[0]} -gt 0 ]]; then
            print_output "[*] Found potential version details in ""$(print_path "$LINE")"
            print_output "[+] Found ""${#VULNS[@]}"" possible vulnerabilities for ""$(basename "$LINE")"" [all versions]:\\n"
            for LINE_ in "${VULNS[@]:0:10}"; do
              print_vul "$LINE_"
            done
            echo
          fi

          if [[ ${#VULNS[@]} -gt 0 ]] && [[ ${#V_OUTPUT[0]} -gt 0 ]] && [[ ${#V_OUTPUT[@]} -gt 0 ]]; then
            print_output "[*] Possible version details for ""$(basename "$LINE")"":"
            for V_VERSION in "${V_OUTPUT[@]}"; do
              print_output "$(indent "$(orange "$V_VERSION")")"
            done
            echo
          fi

          # if we found more than 10 vulnerabilities we try to use version details:
          if [[ ${#VULNS[@]} -gt 10 ]]; then
            for V_VERSION_2 in "${V_OUTPUT[@]}"; do
              # check database with binary name and version:
              if [ -n "$V_VERSION_2" ] ; then
                readarray -t VULNS < <(grep -i "\\s""$(basename "$LINE")""\\s" "$VUL_FEED_DB" | sed "s/\"\"//g" | cut -d\| -f1 | cut -d, -f1,3- | sed "s/,/   /" | cut -d\" -f1,2 | sed "s/\"//" | grep "$V_VERSION_2" 2>/dev/null)
                if [[ ${#VULNS[@]} -gt 0 ]]; then
                  print_output "[+] Found ""${#VULNS[@]}"" possible vulnerabilities for ""$(basename "$LINE")"" [""$V_VERSION_2""] (""$(print_path "$LINE")"")\\n"
                  for LINE_ in "${VULNS[@]:0:20}"; do
                    print_vul "$LINE_"
                  done
                  echo
                fi
              fi
            done
          fi
        fi
      done
    else
      print_output "[!] No vulnerability database found!"
    fi
  fi
  
  if [[ $HTML == 1 ]]; then
     generate_html_file $LOG_FILE $CONTENT_AVAILABLE
  fi
}

print_vul() {
  WIDTH="$(($(tput cols) - 16))"
  readarray -t TEXT_ARR <<<"$1"
  for TEXT in "${TEXT_ARR[@]}"; do
    FIRST_LINE="$(echo "$TEXT" | cut -c 1-"$(($(tput cols) - 2))")"
    LAST_LINES="$(echo "$TEXT" | cut -c "$(($(tput cols) - 1))"-)"

    #LAST_LINES="$(echo "$LAST_LINES" | sed -r "s/(.{""$WIDTH""})/&\n/g")"
    readarray -t L_LINES < <(echo "$LAST_LINES" | sed -r "s/(.{""$WIDTH""})/&\n/g")

    print_output "$FIRST_LINE"
    for E_LINE in "${L_LINES[@]}"; do
      print_output "                ""$( echo "$E_LINE" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    done
    if [[ ${#L_LINES[0]} -gt 0 ]]; then
      echo
    fi
  done
}
